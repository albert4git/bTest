1. Does the file ex1 exist already?
2. No. Okay, is there another file that starts with ex1?
3. Yes, it’s called ex1.c. Do I know how to build .c files?
4. Yes, I run this command cc ex1.c -o ex1 to build them.
5. I shall make you one ex1 by using cc to build it from ex1.c.

$ make clean
$ make ex1

Create an all: ex1 target that will build ex1 with just the command make.
Read man make to find out more information on how to run it.
Read man cc to find out more information on what the flags -Wall and -g do.
Research Makefiles online and see if you can improve this one.
Find a Makefile in another C project and try to understand what it’s doing.

LEARN C
THE HARD WAY
Practical Exercises on the
Computational Subjects You Keep
Avoiding (Like C)
Zed A. Shaw

This chapter covered a lot of ground. You explored pointers in detail.
You should now understand the relationship between pointers and arrays (both
one-dimensional and multidimensional arrays) and have a good grasp of their
uses. I introduced the malloc(), calloc(), and realloc() functions for
dynamically allocating memory, which provide the potential for your programs to
use just enough memory for the data being processed in each run. You also
learned about the complementary function free() that you use to release memory
previously allocated by malloc(), calloc(), or realloc(). You should have a
clear idea of how you can use pointers with strings and how you can use arrays
of pointers, and you should be very comfortable with using pointer notation by
now. The topics I’ve discussed in this chapter are fundamental to a lot of
what follows in the rest of the book, and of course to writing C programs
effectively, so make sure you’re comfortable with the material in this chapter
before moving on to the next.
